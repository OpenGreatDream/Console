using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

namespace NativeFunctionTranslator
{
    public struct Param
    {
        public string VarType;
        public string VarName;

        public Param(string VarType, string VarName)
        {
            this.VarType = VarType;
            this.VarName = VarName;
        }
    }

    public struct ParamList
    {
        public List<Param> paramList;

        public ParamList(int a)
        {
            paramList = new List<Param>();
        }

        public override string ToString()
        {
            string str = string.Empty;
            for (int i = 0; i < paramList.Count; i++)
            {
                Param param = paramList[i];

                if (paramList.Count == 1 || i == paramList.Count - 1)
                {
                    if (param.VarType == string.Empty && param.VarName == string.Empty)
                    {
                        break;
                    }
                    else
                    {
                        str += param.VarType + " " + param.VarName;
                    }
                }
                else
                {
                    str += param.VarType + " " + param.VarName + ", ";
                }
            }
            return str;
        }
    }

    public class Program
    {
        public const string EXPORT_FUNC = "EXPORT_FUNC";
        public const string EXPORT_FUNC_DLLIMPORT = "[DllImport(\"MinConsoleNative.dll\", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Unicode)]";
        public const string EXPORT_FUNC_RETURN_TYPE = "public extern static bool";
        public const int EXPORT_FUNC_INDENT = 8;

        public static List<string> GetFileListWithExtend(DirectoryInfo directory, string pattern)
        {
            List<string> pathList = new List<string>();
            string result = string.Empty;
            if (directory.Exists || pattern.Trim() != string.Empty)
            {
                foreach (FileInfo info in directory.GetFiles(pattern))
                {
                    result = info.FullName.ToString();
                    pathList.Add(result);
                }
            }
            return pathList;
        }

        public static string GetIndentString()
        {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < EXPORT_FUNC_INDENT; i++)
            {
                builder.Append(' ');
            }
            return builder.ToString();
        }

        public static List<string> GetHeadLines()
        {
            List<string> lines = new List<string>();
            lines.Add("using System;");
            lines.Add("using System.Runtime.InteropServices;");
            lines.Add("using static MinConsole.MinConsoleNativeStructs;");
            lines.Add("");
            lines.Add("namespace MinConsole");
            lines.Add("{");
            lines.Add("    //This class is auto generated by NativeFunctionTranslator.");
            lines.Add("    internal static class MinConsoleNativeFuncs");
            lines.Add("    {");
            return lines;
        }

        public static List<string> GetTailLines()
        {
            List<string> lines = new List<string>();
            lines.Add("    }");
            lines.Add("}");
            return lines;
        }

        public static List<string> GetNativeMethodsDeclaration(List<string> headFiles)
        {
            List<string> nativeMethodDeclaration = new List<string>();

            foreach (string headFile in headFiles)
            {
                string text = File.ReadAllText(headFile);
                string[] lines = text.Split(Environment.NewLine);

                foreach (string line in lines)
                {
                    string lineWithOutSpace = line.Trim();

                    if (lineWithOutSpace.IndexOf(EXPORT_FUNC) == -1) continue;

                    //Make sure this is a method declaration
                    bool equal = true;
                    for (int i = 0; i < EXPORT_FUNC.Length; i++)
                    {
                        if (lineWithOutSpace[i] != EXPORT_FUNC[i])
                        {
                            equal = false;
                            break;
                        }
                    }

                    //Don't add duplicate methods
                    if (equal && !nativeMethodDeclaration.Contains(lineWithOutSpace))
                    {
                        nativeMethodDeclaration.Add(lineWithOutSpace);
                    }
                }
            }

            return nativeMethodDeclaration;
        }

        public static List<string> ParseNativeMethodDeclaration(List<string> nativeMethodsDeclaration)
        {
            List<string> nativeMethodNewDeclaration = new List<string>();

            foreach (string item in nativeMethodsDeclaration)
            {
                string declaration = item.Replace(EXPORT_FUNC, EXPORT_FUNC_RETURN_TYPE);

                int leftBracketIndex = declaration.IndexOf('(');
                int rightBracketIndex = declaration.IndexOf(')');
                string parameters = declaration.Substring(leftBracketIndex + 1, rightBracketIndex - leftBracketIndex - 1);

                ParamList newParameters = new ParamList(0);

                //void parameters
                if (string.IsNullOrEmpty(parameters))
                {
                    newParameters.paramList.Add(new Param("", ""));
                }
                else
                {
                    string[] _params = parameters.Split(',');

                    foreach (string _param in _params)
                    {
                        string[] type_names = _param.Split(' ');

                        string varType = string.Empty;
                        //
                        for (int i = 0; i < type_names.Length - 1; i++)
                        {
                            //const param
                            if (type_names[i] == "const")
                            {
                                continue;
                            }
                            //ptr
                            int ptrIndex = type_names[i].LastIndexOf('*');
                            if (ptrIndex != -1)
                            {
                                string _type = type_names[i].Substring(0, ptrIndex);
                                if (_type == "wchar*")
                                {
                                    varType = "ref string";
                                }
                                else if (_type == "wchar")
                                {
                                    varType = "string";
                                }
                                else if (_type == "HWND")
                                {
                                    varType = "IntPtr";
                                }
                                else if (_type == "FARPROC")
                                {
                                    varType = "ref object";
                                }
                                else if (_type == "HANDLE")
                                {
                                    varType = "ref IntPtr";
                                }
                                else
                                {
                                    varType = "ref " + _type;
                                }
                            }
                            //no ptr
                            else
                            {
                                if (type_names[i] == "HWND")
                                {
                                    varType = "IntPtr";
                                }
                                else if (type_names[i] == "DWORD")
                                {
                                    varType = "uint";
                                }
                                else if (type_names[i] == "HICON")
                                {
                                    varType = "ref ICON";
                                }
                                else if (type_names[i] == "wchar")
                                {
                                    varType = "char";
                                }
                                else if (type_names[i] == "HANDLE")
                                {
                                    varType = "IntPtr";
                                }
                                else
                                {
                                    varType = type_names[i];
                                }
                            }
                        }

                        string varName = type_names[type_names.Length - 1];
                        Param param = new Param(varType, varName);
                        newParameters.paramList.Add(param);
                    }
                }

                //add DllImport
                nativeMethodNewDeclaration.Add(GetIndentString() + EXPORT_FUNC_DLLIMPORT);
                //new Declaration
                string newDeclaration = declaration.Substring(0, leftBracketIndex + 1) + newParameters.ToString() + ");";
                nativeMethodNewDeclaration.Add(GetIndentString() + newDeclaration);
                //newline
                nativeMethodNewDeclaration.Add("");
            }

            return nativeMethodNewDeclaration;
        }

        public static void Main(string[] args)
        {
            DirectoryInfo currentDirectory = new DirectoryInfo(Environment.CurrentDirectory);
            string MinConsoleFolder = currentDirectory.Parent.Parent.Parent.Parent.Parent.ToString();

            string MinConsoleNativeFolder = Path.Combine(MinConsoleFolder, "src\\MinConsoleNative");
            string MinConsoleNativeFuncsFile = Path.Combine(MinConsoleFolder, "src\\MinConsole\\MinConsoleNativeFuncs.cs");

            List<string> headFiles = GetFileListWithExtend(new DirectoryInfo(MinConsoleNativeFolder), "*.h");

            List<string> nativeMethodsDeclaration = GetNativeMethodsDeclaration(headFiles);

            //native method result
            List<string> nativeMethodNewDeclaration = ParseNativeMethodDeclaration(nativeMethodsDeclaration);

            //final handling
            List<string> finalLines = new List<string>();
            //add head
            finalLines.AddRange(GetHeadLines());
            //add content
            finalLines.AddRange(nativeMethodNewDeclaration);
            //add tail
            finalLines.AddRange(GetTailLines());

            //add NewLine
            StringBuilder stringBuilder = new StringBuilder();
            finalLines.ForEach(item => { stringBuilder.Append(item + Environment.NewLine); });
            //write to file
            File.WriteAllText(MinConsoleNativeFuncsFile, stringBuilder.ToString(), Encoding.UTF8);

            //foreach (ParamLine item in paramLines)
            //{
            //    for (int i = 0; i < item._params.Count; i++)
            //    {
            //        Param p = item._params[i];
            //        if (item._params.Count == 1 || i == item._params.Count - 1)
            //        {
            //            Console.Write(p.VarType + " " + p.VarName);
            //        }
            //        else
            //        {
            //            Console.Write(p.VarType + " " + p.VarName + ", ");
            //        }
            //    }
            //    Console.WriteLine();
            //}
            //Console.WriteLine("Success!");

            //-----------generate MinConsoleNative.h-----------

            List<FileInfo> headFileInfos = new List<FileInfo>();
            headFiles.ForEach(str => { headFileInfos.Add(new FileInfo(str)); });

            StringBuilder bb = new StringBuilder();
            bb.Append("//This file is auto-generated.\n");
            bb.Append("#pragma once\n\n");
            headFileInfos.ForEach(fi => { bb.Append("#include \"" + fi.Name + "\"\n"); });
            bb.Append("using namespace MinConsoleNative;\n");

            string MinConsoleNativeHPath = Path.Combine(MinConsoleNativeFolder, "MinConsoleNative.h");
            File.WriteAllText(MinConsoleNativeHPath, bb.ToString(), Encoding.UTF8);
        }
    }
}
